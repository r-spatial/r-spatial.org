---
title: "Drawing beautiful maps programmatically with R, sf and ggplot2 â€” Part 3: Layouts"
author: "Mel Moreno and Mathieu Basille"
output:
  html_document:
    fig_caption: no
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: no
  pdf_document:
    toc: yes
    toc_depth: '2'
---


```{r global_options, include = FALSE}
knitr::opts_chunk$set(
    message = FALSE,
    warning = FALSE,
    cache = TRUE,
    tidy = FALSE,
    fig.width = 7,
    fig.height = 7,
    out.width = "65%"
)
## This is just to "pre-load" all packages, and prevent the startup
## messages to show
## Tutorial #1
library("ggplot2")
library("sf")
library("rnaturalearth")
library("rnaturalearthdata")
library("ggspatial")
## Tutorial #2
library("maps")
library("tools")
library("googleway")
library("ggrepel")
## Tutorial #3
library("grid")
library("cowplot")
library("dplyr")
library("viridis")
```

*EDIT: Following a suggestion Adriano Fantini and code from Andy South, we replaced `rworlmap` by `rnaturalearth`.*

This tutorial is the third part in a series of three:

* [General concepts illustrated with the world Map](ggplot2-sf.html)
* [Adding additional layers: an example with points and polygons](ggplot2-sf-2.html)
* Positioning and layout for complex maps (this document)

After the presentation of the basic map concepts, and the flexible approach in layer implemented in `ggplot2`, this section will illustrate how to achieve complex layouts, for instance with map insets, or several maps combined. Depending on the visual information that needs to be displayed, maps and their corresponding data might need to be arranged to create easy to read graphical representations. This tutorial will provide different approaches to arranges maps in the plot, in order to make the information portrayed more aesthetically appealing, and most importantly, convey the information better.


## Getting started

Many R packages are available from [CRAN](https://cran.r-project.org/), the Comprehensive R Archive Network, which is the primary repository of R packages. The full list of packages necessary for this series of tutorials can be installed with:

```{r pkg-install-all, eval = FALSE}
install.packages(c("cowplot", "googleway", "ggplot2", "ggrepel", 
    "ggspatial", "libwgeom", "sf", "rnaturalearth", "rnaturalearthdata"))
```

We start by loading the basic packages necessary for all maps, i.e. `ggplot2` and `sf`. We also suggest to use the classic dark-on-light theme for `ggplot2` (`theme_bw`), which is more appropriate for maps:

```{r pkg-ggplot2-sf}
library("ggplot2")
theme_set(theme_bw())
library("sf")
```

The package `rnaturalearth` provides a map of countries of the entire world. Using `ne_counties` to pull the country data and,choose the scale. For `returnclass`, the setting can for be 'sf' and/or 'sp':

```{r pkg-rnaturalearth}
library("rnaturalearth")
library("rnaturalearthdata")

world <- ne_countries(scale='medium',returnclass = 'sf')
class(world)
```


# General concepts

2 solutions:

* Grobs (graphic objects, allow plots only in plot region, based on coordinates): directly using `ggplot2`
* `ggdraw` (allows plots anywhere, including outer margins, based on relative position): package `cowplot`

Example illustrating the difference between the two, and their use:

```{r inset-example-qplot}
(g1  <- qplot(0:10, 0:10))
```

```{r inset-example-qplot-void, fig.width = 3, fig.height = 3, out.width = "35%"}
(g1_void <- g1 + theme_void() + theme(panel.border = element_rect(colour = "black", 
    fill = NA)))
```

Graphs from `ggplot2` can be saved, like any other R object. They can then be reused later in other functions.

Using grobs, and `annotation_custom`:

```{r inset-example-grobs}
g1 +
    annotation_custom(
        grob = ggplotGrob(g1_void),
        xmin = 0,
        xmax = 3,
        ymin = 5,
        ymax = 10
    ) +
    annotation_custom(
        grob = ggplotGrob(g1_void),
        xmin = 5,
        xmax = 10,
        ymin = 0,
        ymax = 3
    )
```

Using `ggdraw` (note: used to build on top of initial plot; could be left empty to arrange subplots on a grid; plots are "filled" with their plots, unless the plot itself has a constrained ratio, like a map):

```{r inset-example-ggdraw}
ggdraw(g1) +
    draw_plot(g1_void, width = 0.25, height = 0.5, x = 0.15, y = 0.45) +
    draw_plot(g1_void, width = 0.5, height = 0.25, x = 0.50, y = 0.09)
```


# Several maps side by side or on a grid
 
Having a way show in a visualization, a specific area can be very useful. Many scientists usually create maps for each specific area manually. This is fine, but there are simpler ways to display what is needed for a report, or publication. 

This exmaple is using two maps side by side, including the legend of the first one. It illustrates how to use a custom grid, which can be made a lot more complex with different elements.

Prepare the subplots, #1 world:

```{r grid-world, fig.width = 12, fig.height = 5, out.width = "90%"}
(gworld <- ggplot(data = world) +
     geom_sf(aes(fill = region_wb)) +
     geom_rect(xmin = -102.15, xmax = -74.12, ymin = 7.65, ymax = 33.97, 
         fill = NA, colour = "black", size = 1.5) +
     scale_fill_viridis_d(option = "plasma") +
     theme(panel.background = element_rect(fill = "azure"),
         panel.border = element_rect(fill = NA)))
```

And #2 Gulf:

```{r grid-gulf}
(ggulf <- ggplot(data = world) +
     geom_sf(aes(fill = region_wb)) +
     annotate(geom = "text", x = -90, y = 26, label = "Gulf of Mexico", 
         fontface = "italic", color = "grey22", size = 6) +
     coord_sf(xlim = c(-102.15, -74.12), ylim = c(7.65, 33.97), expand = FALSE) +
     scale_fill_viridis_d(option = "plasma") +
     theme(legend.position = "none", axis.title.x = element_blank(), 
         axis.title.y = element_blank(), panel.background = element_rect(fill = "azure"), 
         panel.border = element_rect(fill = NA)))
```

The command `ggplotGrob` signals to `ggplot` to take each created map, and how to arrange each map. The argument `coord_equal` can specify the length, `ylim`, and width, `xlim`, for the entire plotting area. Where as in `annotation_custom`, each maps'  `xmin`, `xmax`, `ymin`, and `ymax` can be specified to allow for complete customization. 

```{rr empty-grobs, fig.width = 15, fig.height = 5, out.width = "90%"}

#Creating a faux empty data frame
df <- data.frame()
plot1<-ggplot(df) + geom_point() + xlim(0, 10) + ylim(0, 10)
plot2<-ggplot(df) + geom_point() + xlim(0, 10) + ylim(0, 10)


ggplot() +
  coord_equal(xlim = c(0, 3.3), ylim = c(0, 1), expand = FALSE) +
  annotation_custom(ggplotGrob(plot1), xmin = 0, xmax = 1.5, ymin = 0, 
                    ymax = 1) +
  annotation_custom(ggplotGrob(plot2), xmin = 1.5, xmax = 3, ymin = 0, 
                    ymax = 1) +
  theme_void()

```

Below is the final map, using the same methodology as the exmaple plot above. Using `ggplot` to arrange maps, allows for easy and quick plotting in one function of R code. 

```{r grid-grobs, fig.width = 15, fig.height = 5, out.width = "90%"} 
ggplot() +
    coord_equal(xlim = c(0, 3.3), ylim = c(0, 1), expand = FALSE) +
    annotation_custom(ggplotGrob(gworld), xmin = 0, xmax = 2.3, ymin = 0, 
        ymax = 1) +
    annotation_custom(ggplotGrob(ggulf), xmin = 2.3, xmax = 3.3, ymin = 0, 
        ymax = 1) +
    theme_void()
```

Using `plot_grid(cowplot)` to arrange `ggplot` figures, is versatile. Any `ggplot` figure can be arranged just like the figure above. There are many commands that allow for the map to have different placements, such as `nrow=1` means that the figure will only occpuy one row and muitple columns, and `ncol=1` means the figure will be plotted on one column and multiple rows. The command `rel_widths` establishes the width of each map, meaning that the first map `gworld` will have a relative width of `2.3`, and the map `ggulf` has the relative width of `1`. 

```{r grid-plot-grid, fig.width = 15, fig.height = 5, out.width = "90%"}
library("cowplot")
theme_set(theme_bw())

plot_grid(gworld, ggulf, nrow = 1, rel_widths = c(2.3, 1))
```

Some other commands can adjust the position of the figures such as adding `align=v` to align vertically on the left axis, and `align=h` to align horiztonally. 

Note also the existence of `get_legend` (`cowplot`), and that the legend can be used as any object.

`ggsave` is OK to be used here.
 
```{r, eval = FALSE}
ggsave("grid.pdf", width = 15, height =  5)
```

---

# Map insets

For map insets directly on the background map, both solutions are viable (and one might prefer one or the other depending on relative or absolute coordinates).

Map example using map of the 50 states of the US, including Alaska and Hawaii (note: not to scale for the latter), using reference projections for US maps. First map (continental states) use a 10/6 figure:

```{r inset-usa, fig.width = 10, fig.height = 6, out.width = "90%"}
usa <- subset(world, admin == "United States of America")
## US National Atlas Equal Area (2163)
## http://spatialreference.org/ref/epsg/us-national-atlas-equal-area/
(mainland <- ggplot(data = usa) +
     geom_sf(fill = "cornsilk") +
     coord_sf(crs = st_crs(2163), xlim = c(-2500000, 2500000), ylim = c(-2300000, 
         730000)))
```

Alaska (note: `datum = NA` removes graticules and coordinates):

```{r inset-alaska, fig.width = 10, fig.height = 6}
## Alaska: NAD83(NSRS2007) / Alaska Albers (3467)
## http://www.spatialreference.org/ref/epsg/3467/
(alaska <- ggplot(data = usa) +
     geom_sf(fill = "cornsilk") +
     coord_sf(crs = st_crs(3467), xlim = c(-2400000, 1600000), ylim = c(200000, 
         2500000), expand = FALSE, datum = NA))
```

Hawaii:

```{r inset-hawaii, fig.width = 10, fig.height = 7}
## Hawaii: Old Hawaiian (4135)
## http://www.spatialreference.org/ref/epsg/4135/
(hawaii  <- ggplot(data = usa) +
     geom_sf(fill = "cornsilk") +
     coord_sf(crs = st_crs(4135), xlim = c(-161, -154), ylim = c(18, 
         23), expand = FALSE, datum = NA))
```

Using `ggdraw` from `cowplot` (tricky to define exact positions; note the use of the ratios of the inset, combined with the ratio of the plot):

```{r inset-ggdraw, fig.width = 10, fig.height = 6, out.width = "90%"}
(ratioAlaska <- (2500000 - 200000) / (1600000 - (-2400000)))
(ratioHawaii  <- (23 - 18) / (-154 - (-161)))

ggdraw(mainland) +
    draw_plot(alaska, width = 0.26, height = 0.26 * 10/6 * ratioAlaska, 
        x = 0.05, y = 0.05) +
    draw_plot(hawaii, width = 0.15, height = 0.15 * 10/6 * ratioHawaii, 
        x = 0.3, y = 0.05)
```

`ggsave` is OK to use:

```{r inset-ggdraw-save, eval = FALSE}
ggsave("map-us-ggdraw.pdf", width = 10, height = 6)
```

Same using grobs (note the use of xdiff/ydiff and arbitrary ratios):

```{r inset-grobs, fig.width = 10, fig.height = 6, out.width = "90%"}
mainland +
    annotation_custom(
        grob = ggplotGrob(alaska),
        xmin = -2750000,
        xmax = -2750000 + (1600000 - (-2400000))/2.5,
        ymin = -2450000,
        ymax = -2450000 + (2500000 - 200000)/2.5
    ) +
    annotation_custom(
        grob = ggplotGrob(hawaii),
        xmin = -1250000,
        xmax = -1250000 + (-154 - (-161))*120000,
        ymin = -2450000,
        ymax = -2450000 + (23 - 18)*120000
    )
```

Save OK with `ggsave`:

```{r inset-grobs-save, eval = FALSE}
ggsave("map-inset-grobs.pdf", width = 10, height = 6)
```
---

The `print` command can also be used place multiple maps in one plotting area. 

To specify where each plot is displayed with the  `print` function, the argument `viewport` needs to specify the maximum width and height of each map, and the minimum x and y coordinates of where the maps are located in the plotting area. The argument `just` will make a position on how the secondary maps will be displayed. All maps are defaulted the same size, until the sizes are adjusted with `width` and `height`.

```{r print_vp}
vp <- viewport(width = 0.37, height = 0.10, x = 0.20, y =0.25, just = c("bottom")) 
vp1<- viewport(width = 0.37, height = 0.10, x = 0.35, y =0.25, just = c("bottom")) 
```

The`print` function uses the previous specifications that were listed in each plots' respective `viewport`, with `vp=`. 

```{r print_finalmap}
print(mainland)
print(alaska, vp=vp)
print(hawaii, vp=vp1)
```


# Several maps connected with arrows

To bring about a more lively map arrangement, arrows can be used to bring the viewers eyes to specific areas in the plotting area. The next example will create a map with zoomed in areas, pointed to by arrows. 

Firstly, we will create our main maps, and then our zoomed in map areas. 

Site coordinates, same as Tutorial #1:

```{r map-arrows-sites}
sites <- st_as_sf(data.frame(longitude = c(-80.15, -80.1), latitude = c(26.5, 
    26.8)), coords = c("longitude", "latitude"), crs = 4326, 
    agr = "constant")
```

Mainlaind map of Florida, #1:

```{r map-arrows-florida}
(florida <- ggplot(data = world) +
     geom_sf(fill = "antiquewhite1") +
     geom_sf(data = sites, size = 4, shape = 23, fill = "darkred") +
     annotate(geom = "text", x = -85.5, y = 27.5, label = "Gulf of Mexico", 
         color = "grey22", size = 4.5) +
     coord_sf(xlim = c(-87.35, -79.5), ylim = c(24.1, 30.8)) +
     xlab("Longitude")+ ylab("Latitude")+
     theme(panel.grid.major = element_line(colour = gray(0.5), linetype = "dashed", 
         size = 0.5), panel.background = element_rect(fill = "aliceblue"), 
         panel.border = element_rect(fill = NA)))
```
  
Site A, #2:

```{r map-arrows-sitea, fig.width = 3, fig.height = 3, out.width = "35%"}
(siteA <- ggplot(data = world) +
     geom_sf(fill = "antiquewhite1") +
     geom_sf(data = sites, size = 4, shape = 23, fill = "darkred") +
     coord_sf(xlim = c(-80.25, -79.95), ylim = c(26.65, 26.95), expand = FALSE) + 
     annotate("text", x = -80.18, y = 26.92, label= "Site A", size = 6) + 
     theme_void() + 
     theme(panel.grid.major = element_line(colour = gray(0.5), linetype = "dashed", 
         size = 0.5), panel.background = element_rect(fill = "aliceblue"), 
         panel.border = element_rect(fill = NA)))
```
  
Site B, #3:

```{r map-arrows-siteb, fig.width = 3, fig.height = 3, out.width = "35%"}
(siteB <- ggplot(data = world) + 
     geom_sf(fill = "antiquewhite1") +
     geom_sf(data = sites, size = 4, shape = 23, fill = "darkred") +
     coord_sf(xlim = c(-80.3, -80), ylim = c(26.35, 26.65), expand = FALSE) +
     annotate("text", x = -80.23, y = 26.62, label= "Site B", size = 6) + 
     theme_void() +
     theme(panel.grid.major = element_line(colour = gray(0.5), linetype = "dashed", 
         size = 0.5), panel.background = element_rect(fill = "aliceblue"), 
         panel.border = element_rect(fill = NA)))
```

Coordinates of the 2 arrows will need to be specified before plotting. The argumemnts `x1`, and `x2` will plot the arrow line from a specific starting x-axis location,`x1`, and ending in a specific x-axis,`x2`. The same applies for `y1` and `y2`, with the y-axis respectively:

```{r map-arrows-arrows}
arrowA <- data.frame(x1 = 18.5, x2 = 23, y1 = 9.5, y2 = 14.5)
arrowB <- data.frame(x1 = 18.5, x2 = 23, y1 = 8.5, y2 = 6.5)
```

Final map using (`ggplot` only). The argument `geom_segment`, are the coordinates created in the previous script, to plot line segments ending with an arrow using `arrow=arrow()`:

```{r map-arrows-plot, fig.width = 10, fig.height = 7, out.width = "90%"}
ggplot() +
    coord_equal(xlim = c(0, 28), ylim = c(0, 20), expand = FALSE) +
    annotation_custom(ggplotGrob(florida), xmin = 0, xmax = 20, ymin = 0, 
        ymax = 20) +
    annotation_custom(ggplotGrob(siteA), xmin = 20, xmax = 28, ymin = 11.25, 
        ymax = 19) +
    annotation_custom(ggplotGrob(siteB), xmin = 20, xmax = 28, ymin = 2.5, 
        ymax = 10.25) +
    geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), data = arrowA, 
        arrow = arrow(), lineend = "round") +
    geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), data = arrowB, 
        arrow = arrow(), lineend = "round") +
    theme_void()
```

`ggsave` works OK for this map.

```{r, eval = FALSE}
ggsave("florida-sites.pdf", width = 10, height = 7)
```

`ggdraw` could also be used for a similar result, with the argument `draw_plot`:

```{r map-arrows-ggdraw, fig.width = 10, fig.height = 7, out.width = "90%"}
ggdraw(xlim = c(0, 28), ylim = c(0, 20)) +
    draw_plot(florida, x = 0, y = 0, width = 20, height = 20) +
    draw_plot(siteA, x = 20, y = 11.25, width = 8, height = 8) +
    draw_plot(siteB, x = 20, y = 2.5, width = 8, height = 8) +
    geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), data = arrowA, 
        arrow = arrow(), lineend = "round") +
    geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), data = arrowB, 
        arrow = arrow(), lineend = "round")
```

# Faceting
  
## `ggplot2` for faceting
The package `rnatural` can also be used to download map data. There are options to retrieve coastlines, countries, and map units. The data gather can be transformed in an "sp" and/or"sf" in the argument `returnclass=  " " `.  In the example below. The map data is faceted with `ggplot` and filled with the income group of each region. This package data can be easily used with `ggplot`. Regardless of the data, `ggplot` faceting has some limitations and much less flexible with the type of data it can plot. 

```{r rnatural_pacakge, fig.width = 12, fig.height = 9, out.width = "100%"}
library("rnaturalearth")

countries<-ne_countries(scale = 110, type = c("countries", "map_units", "sovereignty",
"tiny_countries"),returnclass = "sf")


ggplot(data = countries, aes(fill= income_grp)) +
     geom_sf() +
     theme(panel.grid.major = element_line(colour = gray(0.5), linetype = "dashed", 
         size = 0.5), panel.background = element_rect(fill = "aliceblue"), 
         panel.border = element_rect(fill = NA),
         axis.text.x = element_text(angle = 90)) +
  facet_wrap(~continent, ncol=2) 

```


---

